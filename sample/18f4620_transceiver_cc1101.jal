-- Title: transceiver cc1101 Sample
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q5
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- This file has been generated by hand (manually maintained)
--
-- Description: This is an example for use of the TI cc1101 receiver.
--              Working baud rates are 1.2khz, 100khz and 250khz at 433.92Mhz.
--              This device will also work in the 900mhz range.
--              Max device power is 10dBi
--
-- Notes: I am not an RF genius, do your own testing and check your RF laws.
--        Use SmartRF studio for other settings.
--
-- Sources:
-- https://www.ccsinfo.com/forum/viewtopic.php?t=54957&postdays=0&postorder=asc&start=0
--

include 18f4620                     -- target PICmicro
--
-- This program uses the internal oscillator at 4 MHz.
pragma target clock    32_000_000       -- oscillator frequency
--
pragma target OSC      INTOSC_NOCLKOUT           -- internal oscillator
pragma target WDT      CONTROL                   -- watchdog
pragma target XINST    DISABLED                  -- do not use extended instructionset
pragma target DEBUG    DISABLED                  -- no debugging
pragma target BROWNOUT DISABLED                  -- no brownout reset
pragma target FCMEN    DISABLED                  -- no clock monitoring
pragma target IESO     DISABLED                  -- no int/ext osc switching
pragma target LVP      DISABLED                  -- no low voltage programming
pragma target MCLR     EXTERNAL                  -- external reset
--
-- The configuration bit settings above are only a selection, sufficient
-- for this program. Other programs may need more or different settings.
--
WDTCON_SWDTEN = OFF                 -- disable WDT
OSCCON_SCS = 0                      -- select primary oscillator
OSCCON_IRCF = 0b111                 -- 8 MHz
OSCTUNE_PLLEN = TRUE               -- no PLL
--
enable_digital_io()                 -- make all pins digital I/O
_usec_delay (100_000)               -- wait for power to stablilize

-- Define a led
alias led                       is pin_a0
alias led_direction             is pin_a0_direction
led_direction = output


include delay
include print
include format

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available

print_string(serial_data,"Program Started.")
print_crlf(serial_data)

include spi_master_hw         -- includes the spi library
-- define spi inputs/outputs
pin_sdi_direction = input    -- spi input
pin_sdo_direction = output   -- spi output
pin_sck_direction = output   -- spi clock
--
spi_init(SPI_MODE_11,SPI_RATE_FOSC_64) -- init spi, choose mode and speed
alias spi_master is spi_master_hw
alias spi_master_exchange is spi_master_hw_exchange

-- Configure cc1101
const byte CC1101_BUF_SIZE = 20
--
alias cc1101_chip_select is pin_a1
alias cc1101_chip_select_direction is pin_a1_direction
alias cc1101_gdo0 is pin_a2
alias cc1101_gdo0_direction is pin_a2_direction
--
include transceiver_cc1101
cc1101_init()
;cc1101_config_433_92__1_2_kb()
cc1101_config_433_92mhz_100kbaud()
;cc1101_config_433_92mhz_250kbaud()
cc1101_tx_10dbi()

--
if cc1101_has_error == TRUE then
   print_string(serial_data, "ERROR LOADING CC1101\r\n")
else
   print_string(serial_data, "CC1101 Loaded OK\r\n")
end if

-- main program

-- Called when a good packet is received.
procedure cc1101_good_packet_received_callback(byte in packet_size) is
   print_byte_dec(serial_data,packet_size)
   serial_data = " "
   serial_data = " "
   serial_data = " "
   var byte step = 0
   for packet_size using step loop
      serial_data = " "
      print_byte_hex(serial_data,cc1101_rx_buffer[step])
   end loop
   print_crlf(serial_data)
end procedure
--
-- Called when a bad packet is received.
procedure cc1101_bad_packet_received_callback(byte in error) is
   if error == 0 then
      print_string(serial_data,"ERROR 0: CRC ERROR\r\n");
   elsif error == 1 then
      print_string(serial_data,"ERROR 1: RX buffer overflowed, RX buffer has been cleard.\r\n")
   elsif error == 2 then
      print_string(serial_data,"ERROR 2: RX buffer overflowed, RX buffer has been cleard.\r\n")
   end if
end procedure

forever loop
;   -- TX:
;   var byte i
;   i = 0
;   for 10 using i loop
;      cc1101_tx_buffer[i] = i
;   end loop
;
;   forever loop
;      led = !led
;      delay_1ms(250);
;
;      cc1101_send_packet(10);
;      serial_data = "."
;   end loop

   -- RX:
   forever loop
      -- Wait for new packets.
      cc1101_receive_packet()
      led = !led
   end loop
end loop
