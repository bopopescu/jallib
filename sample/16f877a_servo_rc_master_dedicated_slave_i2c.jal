-- Title: Sample of a dedicated RC servo controller PIC (slave PIC)
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4m
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: This sample creates a dedicated servo slave device that
--              is a dedicated PIC for servo movements. Supports 24 servos that
--              are the type used in radio control (RC)
--
-- This file has been generated by hand (manually maintained)
--
-- Notes:
-- See other servo samples before using this one.
--
-- Master clock/oscillator should be equal or less then slave clock/osc
-- otherwise you may need to limit I2C bus speed.
--
-- Sources:
-- http://www.horrorseek.com/home/halloween/wolfstone/Motors/svoint_RCServos.html
--

-- include chip
include 16f877a                    -- target PICmicro
pragma target clock 20_000_000     -- oscillator frequency
-- configure fuses
pragma target OSC  HS              -- HS crystal or resonator
pragma target WDT  disabled        -- no watchdog
pragma target LVP  enabled         -- allow Low Voltage Programming

enable_digital_io()                -- make all pins digital I/O

--------------------------------------------------------------------------------
-- setup servos
--------------------------------------------------------------------------------

-- setup servo pins
alias servo_1             is pin_b0
alias servo_1_direction   is pin_b0_direction
servo_1_direction = output
--
alias servo_2             is pin_b1
alias servo_2_direction   is pin_b1_direction
servo_2_direction = output
--
alias servo_3             is pin_b2
alias servo_3_direction   is pin_b2_direction
servo_3_direction = output
--
alias servo_4             is pin_b3
alias servo_4_direction   is pin_b3_direction
servo_4_direction = output
--
alias servo_5             is pin_b4
alias servo_5_direction   is pin_b4_direction
servo_5_direction = output
--
alias servo_6             is pin_b5
alias servo_6_direction   is pin_b5_direction
servo_6_direction = output
--
alias servo_7             is pin_b6
alias servo_7_direction   is pin_b6_direction
servo_7_direction = output
--
alias servo_8             is pin_b7
alias servo_8_direction   is pin_b7_direction
servo_8_direction = output
--
alias servo_9             is pin_d0
alias servo_9_direction   is pin_d0_direction
servo_9_direction = output
--
alias servo_10             is pin_d1
alias servo_10_direction   is pin_d1_direction
servo_10_direction = output
--
alias servo_11             is pin_d2
alias servo_11_direction   is pin_d2_direction
servo_11_direction = output
--
alias servo_12             is pin_d3
alias servo_12_direction   is pin_d3_direction
servo_12_direction = output
--
alias servo_13             is pin_d4
alias servo_13_direction   is pin_d4_direction
servo_13_direction = output
--
alias servo_14             is pin_d5
alias servo_14_direction   is pin_d5_direction
servo_14_direction = output
--
alias servo_15             is pin_d6
alias servo_15_direction   is pin_d6_direction
servo_15_direction = output
--
alias servo_16             is pin_d7
alias servo_16_direction   is pin_d7_direction
servo_16_direction = output
;--
;alias servo_17             is pin_a0
;alias servo_17_direction   is pin_a0_direction
;servo_17_direction = output
;--
;alias servo_18             is pin_a1
;alias servo_18_direction   is pin_a1_direction
;servo_18_direction = output
;--
;alias servo_19             is pin_a2
;alias servo_19_direction   is pin_a2_direction
;servo_19_direction = output
;--
;alias servo_20             is pin_a3
;alias servo_20_direction   is pin_a3_direction
;servo_20_direction = output
;--
;alias servo_21             is pin_a5
;alias servo_21_direction   is pin_a5_direction
;servo_21_direction = output
;--
;alias servo_22             is pin_e0
;alias servo_22_direction   is pin_e0_direction
;servo_22_direction = output
;--
;alias servo_23             is pin_e1
;alias servo_23_direction   is pin_e1_direction
;servo_23_direction = output
;--
;alias servo_24             is pin_e2
;alias servo_24_direction   is pin_e2_direction
;servo_24_direction = output


-- choose min & max servo movment / pulse size
var byte servo_min   = 50  -- default is 50  (0.5ms min pulse)
var byte servo_max   = 250 -- default is 255 (2.5ms max pulse)

-- choose pic internal timers
const byte SERVO_USE_TIMER = 0            -- timer for servo's 1 to 8
const byte SERVO_9_TO_16_USE_TIMER = 1    -- timer for servo's 9 to 16
;const byte SERVO_17_TO_24_USE_TIMER = 3   -- timer for servo's 17 to 24
include servo_rc_master -- include the servo library
servo_init()

--------------------------------------------------------------------------------
-- setup i2c slave
--------------------------------------------------------------------------------

include i2c_hw_slave

const byte SLAVE_ADDRESS = 0x6E  -- address of this pic will be 0x6C
i2c_hw_slave_init(SLAVE_ADDRESS) -- init I2C hw slave

-- declare variables

var byte servo_number     -- servo number (first byte to be recieved)
-- servo number holds the commands in 3 most segnificant bits
var bit command_bit_0 at servo_number : 5
var bit command_bit_1 at servo_number : 6
var bit command_bit_2 at servo_number : 7
var byte command

var byte data                      -- holds command data or servo location
var bit reverse_state at data : 0  -- reverse command - reverse state bit (TRUE/FALSE)
var bit on_off_state at data  : 1  -- on_off command - reverse state bit  (ON/OFF)
ALIAS servo_location is data       -- servo location uses all bytes

var byte byte_select = 0           -- counts byte number recieved from master

-- Command names & values, can be compared to most segnificant bits of servo_number
const byte COMMAND_MOVE    = 0     -- move command
const byte COMMAND_REVERSE = 1     -- reverse servo command
const byte COMMAND_ON_OFF  = 2     -- turn servo on/off
const byte COMMAND_MIN     = 3     -- set servo min movement
const byte COMMAND_MAX     = 4     -- set servo max movement

-- When slave reads via I2C, this is the status byte
-- error = Slave did not get the data correctly, data should be sent again by master
-- ready = Slave is ready for another command
-- Other bits allow master to error check recieved data.
var byte i2c_return_data
var bit error at i2c_return_data : 7   -- error bit
var bit ready at i2c_return_data : 6   -- ready bit
var bit error2 at i2c_return_data : 5  -- error2 = same as error
var bit ready2 at i2c_return_data : 4  -- ready2 = same as ready
var bit error3 at i2c_return_data : 3  -- error3 = inverse of error
var bit ready3 at i2c_return_data : 2  -- ready3 = inverse of ready
var bit error4 at i2c_return_data : 1  -- error4 = inverse of error
var bit ready4 at i2c_return_data : 0  -- ready4 = inverse of ready

-- Before including i2c_hw_slave_isr library, several callbacks
-- must be defined (callbacks are procedure which supposed to be defined
-- and be called on appriopriate time)

-- this callback is used when something wrong happened
-- during communication between master and us
procedure i2c_hw_slave_on_error() is
   pragma inline
end procedure

-- this callback is used when master wants to talk to us
-- and our i2c address has been recognized
procedure i2c_hw_slave_on_state_1(byte in _trash) is
   pragma inline
   -- _trash is read from master, but it's a dummy data
   -- usually (always ?) ignored
   byte_select = 0                          -- mark as 1st byte comming in
end procedure

-- This callback is used when master sends a data byte
procedure i2c_hw_slave_on_state_2(byte in rcv) is
   pragma inline

   if byte_select == 0 then
      servo_number = rcv                    -- get the servo number/command
      byte_select = byte_select + 1         -- 2nd byte is next
   elsif byte_select == 1 then
      data = rcv                            -- get the data for the command
      byte_select = byte_select + 1         -- 3rd byte is next
   elsif byte_select == 2 then
      -- get error checking bit and do xor
      if (servo_number ^ data) == rcv then
         error = false                      -- data recieved is ok, no error
      else
         error = true                       -- data recieved is not ok, error
      end if

      ready = FALSE                         -- allow main loop to run
   end if

end procedure

-- this callback is used when master wants to read something
-- from us. It should use i2c_hw_slave_write() to send something
procedure i2c_hw_slave_on_state_3() is
   pragma inline
   error2 = error                            -- set error bit
   ready2 = ready                            -- set ready bit

   error3 = !error                           -- set inverse error bit
   ready3 = !ready                           -- set inverse ready bit
   error4 = !error                           -- set inverse error bit
   ready4 = !ready                           -- set inverse ready bit

   i2c_hw_slave_write_i2c(i2c_return_data)   -- send data to master
end procedure

-- this callback is used when master, after having read something,
-- still wants to read and get data from us.
procedure i2c_hw_slave_on_state_4() is
   pragma inline
end procedure

-- this callback is used when master does not want to talk
-- with us anymore... This is an appropriate place to reset
-- data for instance
procedure i2c_hw_slave_on_state_5() is
   pragma inline
end procedure

-- callbacks are defined, now include ISR
include i2c_hw_slave_isr

--------------------------------------------------------------------------------
-- main program
--------------------------------------------------------------------------------

ready = TRUE -- device is ready for a command
forever loop

   -- stay ready until next command
   while ready == TRUE loop
   end loop

   -- get the command type out of 3 MSB of servo_number
   command = command_bit_2
   command = (command << 1) + command_bit_1
   command = (command << 1) + command_bit_0


   if command == COMMAND_MOVE then
      -- move the servo
      servo_move (servo_location, servo_number)

   elsif command == COMMAND_ON_OFF then
      -- servo command bits are part of servo number so remove the command bits
      command_bit_0 = 0
      command_bit_1 = 0
      command_bit_2 = 0

      -- set servo on/off state and direction
      if servo_number == 1 then
         servo_1_on = on_off_state
      elsif servo_number == 2 then
         servo_2_on = on_off_state
      elsif servo_number == 3 then
         servo_3_on = on_off_state
      elsif servo_number == 4 then
         servo_4_on = on_off_state
      elsif servo_number == 5 then
         servo_5_on = on_off_state
      elsif servo_number == 6 then
         servo_6_on = on_off_state
      elsif servo_number == 7 then
         servo_7_on = on_off_state
      elsif servo_number == 8 then
         servo_8_on = on_off_state
      elsif servo_number == 9 then
         servo_9_on = on_off_state
      elsif servo_number == 10 then
         servo_10_on = on_off_state
      elsif servo_number == 11 then
         servo_11_on = on_off_state
      elsif servo_number == 12 then
         servo_12_on = on_off_state
      elsif servo_number == 13 then
         servo_13_on = on_off_state
      elsif servo_number == 14 then
         servo_14_on = on_off_state
      elsif servo_number == 15 then
         servo_15_on = on_off_state
      elsif servo_number == 16 then
         servo_16_on = on_off_state
;      elsif servo_number == 17 then
;         servo_17_on = on_off_state
;      elsif servo_number == 18 then
;         servo_18_on = on_off_state
;      elsif servo_number == 19 then
;         servo_19_on = on_off_state
;      elsif servo_number == 20 then
;         servo_20_on = on_off_state
;      elsif servo_number == 21 then
;         servo_21_on = on_off_state
;      elsif servo_number == 22 then
;         servo_22_on = on_off_state
;      elsif servo_number == 23 then
;         servo_23_on = on_off_state
;      elsif servo_number == 24 then
;         servo_24_on = on_off_state

      end if
   elsif command == COMMAND_REVERSE then
      -- servo command bits are part of servo number so remove the command bits
      command_bit_0 = 0
      command_bit_1 = 0
      command_bit_2 = 0

            -- set servo on/off state and direction
      if servo_number == 1 then
         servo_1_reverse = reverse_state
      elsif servo_number == 2 then
         servo_2_reverse = reverse_state
      elsif servo_number == 3 then
         servo_3_reverse = reverse_state
      elsif servo_number == 4 then
         servo_4_reverse = reverse_state
      elsif servo_number == 5 then
         servo_5_reverse = reverse_state
      elsif servo_number == 6 then
         servo_6_reverse = reverse_state
      elsif servo_number == 7 then
         servo_7_reverse = reverse_state
      elsif servo_number == 8 then
         servo_8_reverse = reverse_state
      elsif servo_number == 9 then
         servo_9_reverse = reverse_state
      elsif servo_number == 10 then
         servo_10_reverse = reverse_state
      elsif servo_number == 11 then
         servo_11_reverse = reverse_state
      elsif servo_number == 12 then
         servo_12_reverse = reverse_state
      elsif servo_number == 13 then
         servo_13_reverse = reverse_state
      elsif servo_number == 14 then
         servo_14_reverse = reverse_state
      elsif servo_number == 15 then
         servo_15_reverse = reverse_state
      elsif servo_number == 16 then
         servo_16_reverse = reverse_state
;      elsif servo_number == 17 then
;         servo_17_reverse = reverse_state
;      elsif servo_number == 18 then
;         servo_18_reverse = reverse_state
;      elsif servo_number == 19 then
;         servo_19_reverse = reverse_state
;      elsif servo_number == 20 then
;         servo_20_reverse = reverse_state
;      elsif servo_number == 21 then
;         servo_21_reverse = reverse_state
;      elsif servo_number == 22 then
;         servo_22_reverse = reverse_state
;      elsif servo_number == 23 then
;         servo_23_reverse = reverse_state
;      elsif servo_number == 24 then
;         servo_24_reverse = reverse_state

      end if
      
   elsif command == COMMAND_MIN then
      servo_min = data               -- set servo min movement position
   elsif command == COMMAND_MAX then
      servo_max = data               -- set servo mas movement position
   end if

   ready = TRUE -- set ready for next command
end loop
