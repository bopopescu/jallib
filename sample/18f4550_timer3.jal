-- Title: Basic usage of timer3 module
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q2
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: This example shows basic usage of timer3 to output a 1khz
--              square wave, while blinking a led.
--
-- This file has been generated by hand (manually maintained)
--
-- Sources:
--
-- notes:
--
include 18f4550                      -- target PICmicro
--
-- This program assumes that a 20 MHz resonator or crystal
-- is connected to pins OSC1 and OSC2, and USB active.
-- But PIC will be running at 48MHz.
pragma target clock 48_000_000      -- oscillator frequency
--
pragma target OSC      HS_PLL                    -- HS osc + PLL
pragma target PLLDIV   P5                        -- 20 MHz -> 4 MHz
pragma target CPUDIV   P1                        -- Fosc divisor
pragma target USBDIV   P2                        -- USB clock selection
pragma target WDT      CONTROL                   -- watchdog
pragma target XINST    DISABLED                  -- extended instruction set
pragma target DEBUG    DISABLED                  -- debugging
pragma target BROWNOUT DISABLED                  -- brownout reset
pragma target FCMEN    DISABLED                  -- clock monitoring
pragma target IESO     DISABLED                  -- int/ext osc. switch
pragma target VREGEN   ENABLED                   -- voltage regulator
pragma target LVP      ENABLED                   -- low voltage programming
pragma target MCLR     EXTERNAL                  -- reset
--
-- The configuration bit settings above are only a selection, sufficient
-- for this program. Other programs may need more or different settings.
--
WDTCON_SWDTEN = OFF                 -- disable WDT
OSCCON_SCS = 0                      -- select primary oscillator
--
enable_digital_io()                 -- make all pins digital I/O
_usec_delay (100_000) -- wait for power to stablilize

-- timer out def
alias timer_out             is pin_a1
alias timer_out_direction   is pin_a1_direction
--
timer_out_direction = output

-- led def
alias led             is pin_a0
alias led_direction   is pin_a0_direction
--
led_direction = output

-- set all IO as digital
enable_digital_io()

-- init pic interrupt settings
intcon_gie  = on    ; enables all unmasked interrupts
intcon_peie = on    ; enables all unmasked peripheral interrupts

-- Set this to desired interval. timer3 will count up.
-- Interupt will occur when timer_interval rolls
-- over from 65535 to 0
var word timer_interval = 65535 - 2500 -- 63035 = 1khz square wave at 20mhz,
-- output will change every 0.5ms, full wave in 1ms.
-- interrupt occurs every 0.5ms
-- this value can be calculated:
-- 65535    - ( (1/1khz/2) / ( (1/20_000_000)*4 ) ) = 63035
-- timermax - ( (1/HZ/2) / ( (1/OSC FREQ  )*4 ) ) = timer_interval

-- timer3 setup
tmr3 = timer_interval  -- timer interval
t3con_tmr3cs = 0       -- use internal clock
pie2_tmr3ie  = 1       -- enable the timer3 interrupt bit
t3con_tmr3on = 1       -- 1 = enables timer 3
pir2_tmr3if  = off     -- clear overflow to start timer

-- set timer3 clock prescaler
-- each increment slows clock by a multiple of 2
t3con_t3ckps = 0 -- set prscal of 1:1

-----------
procedure timer_isr() is
   pragma interrupt          -- interupt procedure

   if !PIR2_TMR3IF then      -- check if this is a timer3 interupt
      return                 -- exit interupt if it is not
   end if

   PIR2_TMR3IF = off         -- clear overflow to start timer

   timer_out = !timer_out    -- change timer_out pin to oposite value
   TMR3 = timer_interval     -- set the interval
end procedure

-- main program here
forever loop
   _usec_delay (250_000)
   led = on
   _usec_delay (250_000)
   led = off
end loop

