-- Title: Rotary Encoder Sample
-- Author: Matthew Schinkel - justanotherlanguage.org, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q5
--
-- This file is part of jallib  (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: Counts the rotation of a rotary encoder using interrupt on change
--              pins. Position is stored in eeprom for next power on.
--              I tested with encoder OMRON E6B2-CWZ6C 2000P/R with pull up
--              resistors. I may use E6B2-CWZ3E in the future so there
--              is no need for a pull up resistor. This lib may work with other
--              rotary encoders.
--
-- This file has been generated by hand (manually maintained)
--
-- Sources:
-- http://www.mouser.com/ds/2/307/e6b2-c_ds_csm491-25665.pdf
--

-- include chip
include 18f4620                   -- target picmicro
-- this program assumes a 20 mhz resonator or crystal
-- is connected to pins osc1 and osc2.
pragma target osc INTOSC_NOCLKOUT  -- hs crystal or resonator
;pragma target osc hs              -- hs crystal or resonator
;pragma target clock 20_000_000    -- oscillator frequency
pragma target clock 32_000_000    -- oscillator frequency
--
pragma target wdt  CONTROL
pragma target lvp  enabled 
pragma target MCLR external        -- reset externally
--
;OSCCON_IRCF = 0b110   -- set int osc to 4mhz
OSCCON_IRCF = 0b111   -- set internal osc to 8mhz
OSCTUNE_PLLEN = true  -- multiply internal osc by 4
--
enable_digital_io()                -- make all pins digital I/O
--
_usec_delay(100_000) -- wait for power to settle

include delay
include print

-- setup uart for communication
const serial_hw_baudrate  = 115200   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available

include pic_data_eeprom

-- alias the interrupt flags so they are readable.
alias INT_0_ENABLE_BIT is INTCON_INT0IE
alias INT_0_FLAG_BIT is INTCON_INT0IF
alias INT_0_EDGE_BIT is INTCON2_INTEDG0

-- enable global interrupts
INTCON_GIE  = TRUE        -- Enables all unmasked interrupts
INTCON_PEIE = TRUE        -- Enables all unmasked peripheral interrupts

-- define rotary encoder pins
alias re1_a is pin_B0
alias re1_a_direction is pin_B0_direction
re1_a_direction = INPUT
--
alias re1_b is pin_B1
alias re1_b_direction is pin_B1_direction
re1_b_direction = INPUT
--
-- rotery encoder z pin is not required
;alias re1_z is pin_B2
;alias re1_z_direction is pin_B1_direction
;re1_z_direction = INPUT

-- enable interrupt on change pin
INT_0_ENABLE_BIT = TRUE   -- interrupt pin enable bit for B0
procedure rotery_encoder_changed() -- procedure is written later

-- main interrupt handler
procedure re_interrupt() is
   pragma interrupt
   -- Check if interrupt pin 0 (B0 re1_a) has an interrupt.
   if INT_0_FLAG_BIT then
      rotery_encoder_changed() -- call our rotery encoder procedure
      INT_0_FLAG_BIT = FALSE -- reset interrupt flag
   end if
end procedure

-- variable to count position
var sdword int_count
var dword int_count_temp
data_eeprom_read_dword(0,int_count_temp)
int_count = sword(int_count_temp) + 1

-- interrupt for pin B0
-- try not to do much in here
procedure rotery_encoder_changed() is
   pragma inline

   if re1_b == HIGH then
      int_count = int_count + 1
   else
      int_count = int_count - 1
   end if
end procedure

-- Set the current position (default is 0)
procedure re1_set_position(sdword in center) is
   data_eeprom_write_dword(0,dword(center))
   int_count = center
end procedure

-- Set the center position (add a button?)
;re1_set_position(0)

-- report current position
print_sdword_dec(serial_data,int_count)
print_crlf(serial_data)

-- Create clock pulses to trigger our interrupt
-- Connect this output to pin B0.
var sdword int_count_prev
forever loop
   -- print only when position changes
   if int_count != int_count_prev then
      -- store value in eeprom for next power on
      data_eeprom_write_dword(0,dword(int_count - 1))

      -- report the position
      print_sdword_dec(serial_data,int_count)
      print_crlf(serial_data)
      
      int_count_prev = int_count
   end if
end loop

