-- Title: Frequency Counter (Oscillator Input Pin)
-- Author: Matthew Schinkel - borntechi.com, copyright (c) 2009, all rights reserved.
-- Adapted-by:
-- Compiler: >=2.4q5
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
--
-- Description: A frequency counter using the Oscillator input pin as the
--              source input pin.
--
-- This file has been generated by hand (manually maintained)
--
-- Sources:
--
-- Notes:
--        - I have no reliable clock sources, and run it on a breadboard.
--        - I got a reading about 98.8% accurate.
--
--        - Can measure up to 40mhz.
--
--        - Oscillator in pin is the signal pin.
--        - Interrupt on change pin must have an accurate 1hz signal.
--
--        - This sample only works at 1Mhz. If you input any other frequency, you will
--        - need to output the meansurement to a source that is not frequency dependant
--          such as 7 segment displays.
--
--        - Readings are in increments of 256 (size of a 8 bit timer)
--

include 18f4620                      -- target PICmicro
--
-- This program assumes that a 20 MHz resonator or crystal
-- is connected to pins OSC1 and OSC2.
pragma target clock 1_000_000      -- oscillator frequency
--
pragma target OSC      EC_NOCLKOUT               -- crystal or resonator
pragma target WDT      CONTROL                   -- watchdog
pragma target XINST    DISABLED                  -- extended instruction set
pragma target DEBUG    DISABLED                  -- debugging
pragma target BROWNOUT DISABLED                  -- brownout reset
pragma target FCMEN    DISABLED                  -- clock monitoring
pragma target IESO     DISABLED                  -- int/ext osc. switch
pragma target LVP      ENABLED                   -- low voltage programming
pragma target MCLR     EXTERNAL                  -- reset
--
-- The configuration bit settings above are only a selection, sufficient
-- for this program. Other programs may need more or different settings.
--
WDTCON_SWDTEN = OFF                 -- disable WDT
OSCCON_SCS = 0                      -- select primary oscillator
OSCTUNE_PLLEN = TRUE               -- PLL
--
enable_digital_io()                 -- make all pins digital I/O

alias led                       is pin_a0
alias led_direction             is pin_a0_direction
led_direction = output

include print

-- setup uart for communication
const serial_hw_baudrate  = 9600   -- set the baudrate
include serial_hardware
serial_hw_init()
-- some aliases so it is easy to change from serial hw to serial sw.
alias serial_write is serial_hw_write
alias serial_read is serial_hw_read
alias serial_data is serial_hw_data
alias serial_data_available is serial_hw_data_available

print_string(serial_data,"Program Started.")
print_crlf(serial_data)

-- choose pins to use for int on change
const byte int_on_change_pins[] = {"B",5}
include interrupt_on_change
int_on_change_init()

-- timer setup
const byte TIMER0_PS_RATIO = 1          -- set prescaller ratio
const byte TIMER0_BITS = 8              -- Use 8 or 16 bits
const byte TIMER0_ENABLE_INTERRUPT = 0  -- Interrupts off/on
include timer0
timer_init()                          -- enables interrupt, starts timer
--
;pin_T0CKI_direction = input
;T0CON_T0CS = 1 -- Clock Transition on T0CKI pin
T0CON_T0CS = 0 -- Clock Transition internal clock
;T0CON_T0SE = 0 -- edge bit

var dword step
step = 0

-- This proc is active if TIMER0_ENABLE_INTERRUPT is enabled.
procedure timer_isr() is
   pragma interrupt          -- interupt procedure

   if !timer0_if then      -- check if this is a interupt
      return               -- exit interupt if it is not
   end if

   timer0_if = off         -- clear overflow to start timer
   step = step + 1
end procedure

const SDWORD ADJUST = 0 -- adjust by # of clock cycles
const byte INSTRUCTIONS_PER_CLOCK = 4

-- interrupt for pin B4
var bit toggle = 0
procedure int_on_change_callback_0() is
   pragma inline

   toggle = !toggle ; count from only one edge
   if toggle == TRUE then
      var dword meansurement = (step*256*INSTRUCTIONS_PER_CLOCK) + ADJUST
      print_dword_dec(serial_data,meansurement)
      print_crlf(serial_data)
      step = 0
   end if
end procedure

-- main loop
var bit has_stepped = 0
forever loop
   -- monitor for timer overflows, if interrupts are disabled.
   if TIMER0_ENABLE_INTERRUPT == 0 then
      if timer0 > 128 then
         if has_stepped == 0 then
            step = step + 1
            has_stepped = 1
         end if
      else
         has_stepped = 0
      end if
   end if
end loop

