-- Title: XBee API receiving sample
-- Author: Sebastien Lelong, Copyright (c) 2012, all rights reserved.
-- Adapted-by: Rob Hamerling
-- Compiler: 2.4q2
--
-- This file is part of jallib (https://github.com/jallib/jallib)
-- Released under the ZLIB license (http://www.opensource.org/licenses/zlib-license.html)
--
-- Description: this sample show how to use xbee_api library to receive
-- data through XBee in API mode.
-- See tutorial here:
--  - http://jaluino.org/building-xbee-network-part-1
--  - http://jaluino.org/building-xbee-network-part-2
-- Derived from a Jaluino sample
--
-- This file has been generated by hand (manually maintained)
--

-- Xtal 16MHz w/ PLL, system clock 48MHz
include 18f27j53
pragma target clock 48_000_000   -- oscillator frequency
-- magical statements
pragma target PLLDIV    P4
pragma target CPUDIV    P1
pragma target PLLEN  disabled    -- PLL via fuse turned off
pragma target OSC    HS_PLL
OSCTUNE_PLLEN = on               -- PLL via OSCTUNE enabled
pragma target WDT    control     -- watchdog
WDTCON_SWDTEN = off              -- no watchdog
-- declare secondary oscillator on T1OSI/T1OSO pins
pragma target RTCOSC T1OSC
pragma target SOSCSEL HP
_usec_delay(2000) -- PLL needs 2ms before stable

enable_digital_io()

alias onboard_led is pin_C2
alias onboard_led_direction is pin_C2_direction

include delay
include print

const serial_hw_baudrate = 9_600
include serial_hardware
serial_hw_init()
alias xbee_carrier is serial_hw_data

-- we'll output received data through the other serial module
-- configure pins through PPS as:
--  * B7 <= RX2
--  * B6 => TX2
include pps
-- PPS module writes are protected, we need to first unlock it
pps_control_lock(false)
-- TX2 is an output function: we assign a function to a RP pin (here RP9)
PPS_MAP_RP9 = PPS_TX2CK2
-- RX2 is an input function: we assign a RP pin the a function register
PPS_MAP_RX2DT2 = RP10
-- PPS configuration is done, we can lock again to apply changes
pps_control_lock(true)
-- declare aliases for the remapped RX2 and TX2 pins
alias pin_RX2            is  pin_RP10
alias pin_RX2_direction  is  pin_RP10_direction
alias pin_TX2            is  pin_RP9
alias pin_TX2_direction  is  pin_RP9_direction
const SERIAL_HW2_BAUDRATE = 115_200
include serial_hardware2
serial_hw2_init()


const byte XBEE_PAYLOAD_SIZE = 2
include xbee_api
xbee_init()

-- (for the record)
-- Me, the source Xbee has the following addresses
-- SH: 13A200
-- SL: 4054F82F

-- Assuming LED is enable on hajumper)
onboard_led_direction =  output
-- receving loop
forever loop

   var byte i

   xbee_read_packet()
   const byte msg[] = "--Response--"
   const byte api_id[] = "api_id: "
   const byte frame_id[] = "frame_id: "
   const byte frame_data[] = "frame_data: "
   const byte msb_length[] = "msb_length: "
   const byte lsb_length[] = "lsb_length: "
   const byte checksum[] = "checksum: "
   const byte frame_length[] = "frame_length: "
   const byte complete[] = "complete: "
   const byte error_code[] = "error_code: "
   const byte payload[] = "payload: "

   print_string(serial_hw2_data,msg)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,api_id)
   print_byte_hex(serial_hw2_data,xbee_res.api_id)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,frame_id)
   print_byte_hex(serial_hw2_data,xbee_res.frame_id)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,msb_length)
   print_byte_hex(serial_hw2_data,xbee_res.msb_length)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,lsb_length)
   print_byte_hex(serial_hw2_data,xbee_res.lsb_length)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,frame_length)
   print_byte_hex(serial_hw2_data,xbee_res.frame_length)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,checksum)
   print_byte_hex(serial_hw2_data,xbee_res.checksum)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,complete)
   print_bit_logic(serial_hw2_data,xbee_res.complete)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,error_code)
   print_byte_hex(serial_hw2_data,xbee_res.error_code)
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,frame_data)
   for xbee_res.frame_length using i loop
       print_byte_hex(serial_hw2_data,xbee_res.frame_data[i])
   end loop
   print_crlf(serial_hw2_data)
   --
   print_string(serial_hw2_data,payload)
   for XBEE_PAYLOAD_SIZE loop
       serial_hw2_data = xbee_res_payload
   end loop
   print_crlf(serial_hw2_data)

end loop



